<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Full description &#8212; Featurecloud  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=68bc434f" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="full-description">
<h1>Full description<a class="headerlink" href="#full-description" title="Link to this heading">¶</a></h1>
<section id="defining-states-and-running-applications">
<h2>Defining states and running applications<a class="headerlink" href="#defining-states-and-running-applications" title="Link to this heading">¶</a></h2>
<p>FeatureCloud provide an advantageous platform to develop Federated applications.
FeatureCloud includes different components to develop applications in a privacy-preserving fashion and present
them to researchers and practitioners. FeatureCloud AI store includes different exciting applications developed by
FeatureCloud community, a testbed to facilitate app development for developers, and project front-end for FeatureCloud
end-users to run desired workflows containing multiple applications. For registering and testing your apps
or using other apps, please visit <a class="reference external" href="https://featurecloud.ai/">FeatureCloud.ai</a>. And for more information about
FeatureCloud architecture, please refer to our paper:
<a class="reference external" href="https://arxiv.org/abs/2105.05734">The FeatureCloud AI Store for Federated Learning in Biomedicine and Beyond</a> <a class="reference external" href="#1">[1]</a>.</p>
<p>FeatureCloud library provides app developers with  <code class="docutils literal notranslate"><span class="pre">AppState</span></code> and <code class="docutils literal notranslate"><span class="pre">App</span></code> classes that are responsible for defining states and executing the app instance, respectively.
Each app, in the FeatureCloud platform includes multiple states
and possible transitions between the defined states. All apps will begin their workflow from the <code class="docutils literal notranslate"><span class="pre">initial</span></code> state
and end it at the <code class="docutils literal notranslate"><span class="pre">terminal</span></code> state. Accordingly, <code class="docutils literal notranslate"><span class="pre">App</span></code> class will manage stets and transitions registration.
FeatureCloud <code class="docutils literal notranslate"><span class="pre">App</span></code> supports exactly two roles, coordinator and participant, for clients who are going to participate
in Federated execution of apps. FeatureCloud app developers are obliged to explicitly define their logic
for the app by stipulating which roles are allowed to enter a specific state and take a particular transition.</p>
<section id="roles">
<h3>Roles<a class="headerlink" href="#roles" title="Link to this heading">¶</a></h3>
<p>In the FeatureCloud platform, clients can have two roles: coordinator and participant. These roles are not mutually exclusive.
Meanwhile, the FeatureCloud library comes with three constant tuples to describe the eligibility of clients in terms of
their role to enter and execute specific states.  Accordingly, to make it clear, we defined three role tuples, with <code class="docutils literal notranslate"><span class="pre">bool</span></code> values,
for participant and coordinator roles, as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">COORDINATOR</span></code>: indicates that only coordinator role is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PARTICIPANT</span></code>: indicates that only participant role is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BOTH</span></code>: indicates that both roles are <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
<p>FeatureCloud app developers can use these constants for defining roles for states and transitions.</p>
</section>
<section id="operational-states">
<h3>Operational States<a class="headerlink" href="#operational-states" title="Link to this heading">¶</a></h3>
<p>Once states are executing, any exceptions or errors can happen that can be handled automatically by the app.
For reporting the situation for the front-end app, so end-users be aware of it, currently, three key values can be communicated to the controller:</p>
<p>FeatureCloud app developers can use these pre-defined values for updating the front-end for end-users.</p>
</section>
<section id="log-levels">
<h3>Log levels<a class="headerlink" href="#log-levels" title="Link to this heading">¶</a></h3>
<p>For proper logging and observing them in the front-end, there is a constant <code class="docutils literal notranslate"><span class="pre">LogLevel</span></code> enumerator that includes the following levels:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DEBUG</span></code>: should be used once developers want to show some debug-related logs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ERROR</span></code>: Once the app catches some errors, this log-level helps to properly message the error in the front-end while app execution will be terminated by raising <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.
<code class="docutils literal notranslate"><span class="pre">FATAL</span></code>: Like <code class="docutils literal notranslate"><span class="pre">ERROR</span></code>, it can be used to log fatal events that the app may encounter during the execution.</p></li>
</ul>
</section>
<section id="secure-multi-party-computation-smpc">
<h3>Secure Multi-Party Computation (SMPC)<a class="headerlink" href="#secure-multi-party-computation-smpc" title="Link to this heading">¶</a></h3>
<p>Despite privacy-awareness in Federated Learning, not sending around raw data, there are a couple of steps
to strengthen privacy issues. In that regard, FeatureCloud provides Secure Multi-Party Computation (SMPC)
module for aggregating clients’ data. In the SMPC component, you can include all or at least two of clients as Computational
Parties (CP). Those parties will receive exclusively either noisy data or noises from clients. No CP will receive both
noise and noisy data parts from the same client. The amount of noise that should be used to make data noisy can be tricky.
On one side, excessive noise can damage the results, and on the other hand, slight noises can compromise privacy.
After getting noisy data and/or noises, each CP sums up the data and moves the results to the coordinator.
Finally, the coordinator will conclude the aggregation phase.
SMPC component is part of FeatureCloud Controller, and we encourage developers to have a basic understanding of its application
to provide the controller with proper SMPC configuration. For more information about the SMPc module, please visit <a class="reference external" href="https://featurecloud.ai/">FeatureCloud.ai</a>
or refer to our <a class="reference external" href="https://arxiv.org/abs/2105.05734">paper</a> <a class="reference external" href="#1">[1]</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SMPCType</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">operation</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">]</span>
    <span class="n">serialization</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;json&#39;</span><span class="p">]</span>
    <span class="n">shards</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">exponent</span><span class="p">:</span> <span class="nb">int</span>
</pre></div>
</div>
</section>
</section>
<section id="exponent">
<h2>Exponent<a class="headerlink" href="#exponent" title="Link to this heading">¶</a></h2>
<p>By randomly drawing a noise value, we generate the noise for
making the data noisy. Regarding the fact that noise values cannot
be zero or negative, the Exponent should be a non-negative integer where zero practically means not using the SMPC component.</p>
</section>
<section id="shards">
<h2>Shards<a class="headerlink" href="#shards" title="Link to this heading">¶</a></h2>
<p>Each client should send out noise and noisy data to Computational Parties (CP), between two and the number of clients.
Noise can be made of one or more secrete values, and clients should generate those secrete random values regarding the
number of shards. For instance, once the shards are two, clients should send out one secrete value,
and noisy data, of course, to different CPs. For three or more shards, more secrete values should be generated.
Even though the maximum number of parties yields the best privacy-preserving results,
it is computationally expensive. Accordingly, <code class="docutils literal notranslate"><span class="pre">shards</span></code> is a non-negative integer, where choices are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>: Maximum number of computational parties(Number of clients)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>: Practically, the SMPS module will not be used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Values</span> <span class="pre">greater</span> <span class="pre">than</span> <span class="pre">one</span></code>: indicates the number of Computational parties that will be involved.
For values greater than the number of clients, all clients will be involved as CPs.</p></li>
</ul>
</section>
<section id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Link to this heading">¶</a></h2>
<p>For employing noise to the clients’ data, we can use different operations. Currently, FeatureCloud supports
two of the most common operations to make noisy data: add and multiply. App-developers can choose between
these two options, by providing the string value of <code class="docutils literal notranslate"><span class="pre">add</span></code> or <code class="docutils literal notranslate"><span class="pre">multiply</span></code>, or simply to avoid typos, they can
use following constants:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">OPERATION_ADD</span> <span class="o">=</span> <span class="s1">&#39;add&#39;</span>
<span class="n">OPERATION_MULTIPLY</span> <span class="o">=</span> <span class="s1">&#39;multiply&#39;</span>
</pre></div>
</div>
</section>
<section id="serialization">
<h2>Serialization<a class="headerlink" href="#serialization" title="Link to this heading">¶</a></h2>
<p>To communicate data between clients and the aggregated results of the SMPC module to the coordinator, we should use serialization.
For serialization technique, FeatureCloud library currently supports <code class="docutils literal notranslate"><span class="pre">json</span></code> and <code class="docutils literal notranslate"><span class="pre">pickle</span></code> libraries. For communicating
data to the SMPC component and from SMPc to the coordinator, we use <code class="docutils literal notranslate"><span class="pre">json</span></code>, which only accepts Python list, dictionary, and tuple.
We use <code class="docutils literal notranslate"><span class="pre">pickle</span></code> for all other communications, supporting more complicated structures like Pandas Dataframes and Series and NumPy arrays.</p>
<section id="app-class">
<h3>App class<a class="headerlink" href="#app-class" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">App</span></code> class is the central part of the FeatureCloud engine responsible for registering states, transit between states, and managing their state executions,
in general. Developers do not need to be familiar with <code class="docutils literal notranslate"><span class="pre">App</span></code> class; however, they should be aware of some principles that developers should follow.</p>
<p>Generally, two types of clients are used in FeatureCloud:</p>
<ul class="simple">
<li><p>participant: Every participant in the FeatureCloud platform, except for one, the coordinator,
is considered a participant who should perform local tasks and communicate some intermediary results with the coordinator.
Of course, no raw data are supposed to be exchanged among clients and the coordinator.</p></li>
<li><p>coordinator: One of the clients who can receive results of other clients, aggregate, and broadcast them.</p></li>
</ul>
<p>For registering either states or transitions, app developers must use one of these constants
to declare that each role/s are responsible/allowed to execute states or take transitions. <code class="docutils literal notranslate"><span class="pre">App</span></code> class
automatically checks the logic to ensure semantic errors in defining the workflow are minimized.</p>
<p>Each app should contain and start with an <code class="docutils literal notranslate"><span class="pre">initial</span></code> state. On the other hand, each app, by default, contains
the <code class="docutils literal notranslate"><span class="pre">terminal</span></code> state that has no task or operation to accomplish other than explicitly
marking the final state in the app. Once a state transitions to the <code class="docutils literal notranslate"><span class="pre">terminal</span></code> state, that state should be considered one of the app’s possible exit states.</p>
</section>
</section>
<section id="status-attributes">
<h2>Status Attributes<a class="headerlink" href="#status-attributes" title="Link to this heading">¶</a></h2>
<p>When the app instance is running, different errors may happen, or various results may be produced. Thereby, the app instance may need
to communicate with the controller or front-end parts of FeatureCloud. Accordingly, developers can use status
attributes in the <code class="docutils literal notranslate"><span class="pre">App</span></code> class to send messages between the app container to the controller and/or indirectly with the front-end.
Beware that app containers are not directly connected to the front-end, and they should communicate through the controller.</p>
<p>Once a client wants to communicate with other clients, regardless of role, and the data is ready, by setting
<code class="docutils literal notranslate"><span class="pre">app.status_available</span></code> as <code class="docutils literal notranslate"><span class="pre">True</span></code>, the app instance sends the signal to the controller to execute the communication. Generally, this attribute will be used for <a class="reference external" href="#communication-methods">communication methods</a> and automatically handled by the FeatureCloud app.</p>
<p>The app instance can set <code class="docutils literal notranslate"><span class="pre">app.status_finished</span></code> attribute as <code class="docutils literal notranslate"><span class="pre">True</span></code> to signal the controller that app execution is finished.
Generally, this attribute will be set as True by the FeatureCloud app once the app enters the <code class="docutils literal notranslate"><span class="pre">terminal</span></code> state or some
exceptions happen during the app run.</p>
<p>Once there is a specific massage, e.g., the occurrence of some semantic errors, app instance can use <code class="docutils literal notranslate"><span class="pre">app.status_message</span></code>
to inform the end-user in front-end.  For sending messages to front-end, developers can use <cite>``app.update`</cite> &lt;#updating-local-app-status-update&gt;`_.</p>
<p>During the run, app execution progress can be quantified based on different factors. Developers can quantify the app
progress in the range of zero to one and share it with end-user through the front-end using <cite>``app.update`</cite> &lt;#updating-local-app-status-update&gt;`_.</p>
<p>During the app run, different <a class="reference external" href="#operational-states">operational states</a> can be reported to the end-user using <cite>``app.update`</cite> &lt;#updating-local-app-status-update&gt;`_.</p>
<p>Once clients want to communicate with another client, they should provide the ID of the target client for the coordinator.
Developers should use <code class="docutils literal notranslate"><span class="pre">destination</span></code> argument in <a class="reference external" href="#communication-methods">communication methods</a> for this purpose and <code class="docutils literal notranslate"><span class="pre">status_destination</span></code>
will be accordingly and automatically handled by app instance.</p>
<p>App developers can decide which parameters should be used SMPC aggregation, and they can inform the controller about the
configuration using <cite>``app.configure_smpc`</cite> &lt;#configuring-smpc-module-configure_smpc&gt;`_.</p>
</section>
<section id="shared-memory-for-states-app-internal">
<h2>Shared memory for states: <code class="docutils literal notranslate"><span class="pre">_app.internal</span></code><a class="headerlink" href="#shared-memory-for-states-app-internal" title="Link to this heading">¶</a></h2>
<p>Different states can be defined and registered to the app, and they may need to pass data to each other. To support a shared memory
between different states, the <code class="docutils literal notranslate"><span class="pre">App</span></code> class has an <code class="docutils literal notranslate"><span class="pre">internal</span></code> attribute, a dictionary that can be accessed through
<code class="docutils literal notranslate"><span class="pre">self._app.iternal</span></code> in each state. However, the <code class="docutils literal notranslate"><span class="pre">app</span></code> instance is a private attribute for <code class="docutils literal notranslate"><span class="pre">AppState</span></code> and should not be accessed
directly. Thereby, <code class="docutils literal notranslate"><span class="pre">load</span></code> and <code class="docutils literal notranslate"><span class="pre">store</span></code> methods are introduced to the <code class="docutils literal notranslate"><span class="pre">AppState</span></code> class to cover sharing data among different states.</p>
</section>
<section id="registration-methods">
<h2>Registration methods<a class="headerlink" href="#registration-methods" title="Link to this heading">¶</a></h2>
<p>The FeatureCloud app includes various methods that not only provides
the ability to flexibly incorporate different states into the app but also work as part of the <a class="reference external" href="#verification-mechanism">verification mechanism</a>.</p>
<p>Once all the states are registered and ready to run, <code class="docutils literal notranslate"><span class="pre">app.register()</span></code> should be called to register all the transitions.
This is one part of <a class="reference external" href="#verification-mechanism">Verification mechanism</a>.</p>
<p>Once the state is submitted by calling <a class="reference external" href="#registering-states-to-the-app-app_state">app_state</a>, <code class="docutils literal notranslate"><span class="pre">_register_state</span></code> will be
automatically called to instantiate the state class and assign the roles and name. Generally, developers should extend
<code class="docutils literal notranslate"><span class="pre">AppState</span></code> and implement abstract classes; the defined state may have arguments that can be passed to using <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>.</p>
<ul class="simple">
<li><p>name: name of the state(which will be used in logging and creating transitions)</p></li>
<li><p>state: AppState class or any extensions of it.</p></li>
<li><p>participant: a boolean flag that indicates whether participants are allowed to enter the state or not.</p></li>
<li><p>coordinator: a boolean flag that indicates whether the coordinator is allowed to enter the state or not.</p></li>
</ul>
<p>It has a similar application as <code class="docutils literal notranslate"><span class="pre">_register_state</span></code> except it registers states. It receives the names of source and
target states and registers a transition between them. Meanwhile, it checks the logic and raises <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> if apps try to register a
transitions with contradicting roles.</p>
</section>
<section id="execution-methods">
<h2>Execution methods<a class="headerlink" href="#execution-methods" title="Link to this heading">¶</a></h2>
<p>During the run, app instances need to transition between different states, execute them and provide logs.</p>
<p>Transits the app workflow to the next state based on current states, the role FeatureCloud client,
and requirements of registered transitions for the current state. For transition to a specific state, this method needs the
target state’s name and considers the current state as the source state.</p>
<p>The main method in <code class="docutils literal notranslate"><span class="pre">App</span></code> class runs the workflow while logging the current state execution
and transits to the next desired state. Meanwhile, once the app transits to the finish state,
the workflow will be terminated.</p>
<p>Prints a log message or raises an exception according to the <a class="reference external" href="#log-levels">log level</a>.</p>
<section id="appstate-defining-custom-states">
<h3>AppState: Defining Custom States<a class="headerlink" href="#appstate-defining-custom-states" title="Link to this heading">¶</a></h3>
<p>To Support all sorts of operations and communications, FeatureCloud’s engine package includes <code class="docutils literal notranslate"><span class="pre">AppState</span></code>
class. It is an abstract class that requires App-developers to extend it by defining its <a class="reference external" href="#abstract-methods">abstract methods</a>.
Sates will be assigned to clients with specific roles, and the FeatureCloud app will verify all states and their
corresponding transitions based on these predefined roles. In this way,
the app’s logic can be verified before deploying it(more on this <a class="reference external" href="#verification-mechanism">here</a>). Each state
should have a unique name that, by default, will be used for naming transitions. Also, for roles, developers
should set <code class="docutils literal notranslate"><span class="pre">participant</span></code> and <code class="docutils literal notranslate"><span class="pre">coordinator</span></code> attributes(which we strongly recommend to use <cite>``app_state`</cite> &lt;#registering-states-to-the-app-app_state&gt;`_ handler).<span class="raw-html-m2r"><br></span>
Also, for each state, the app instance should be assigned, so states can have access to the app’s attributes,
especially <code class="docutils literal notranslate"><span class="pre">internal</span></code> attribute that should be used as a shared memory between all states.</p>
<p><code class="docutils literal notranslate"><span class="pre">AppState</span></code> includes generic methods for sending data around that all use <code class="docutils literal notranslate"><span class="pre">json</span></code> serialization when using SMPC and <code class="docutils literal notranslate"><span class="pre">pickle</span></code> for other communications.
To provide a more secure way of communicating data, FeatureCloud incorporates Secure Multi-Party Computation (SMPC),
and regarding using it or not, different serialization methods will be used:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">json</span></code>: will be used once we do not use SMPC for aggregation and can handle Numpy arrays and Panda DataFrames and Series.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pickle</span></code>: will be used once SMPC is used for aggregation and only supports Python lists, tuples, and dictionaries.</p></li>
</ul>
<p>Therefore, app developers should consider data type and structure when they communicate data that should be aggregated.
The data may not be in the same structure or type as they were sent out.</p>
</section>
</section>
<section id="id7">
<h2>Abstract methods<a class="headerlink" href="#id7" title="Link to this heading">¶</a></h2>
<p>For developing apps in FeatureCloud, developers need to extend <code class="docutils literal notranslate"><span class="pre">AppState</span></code> class to define their states. And for
implementing new states, developers are only required to implement two abstract methods, <code class="docutils literal notranslate"><span class="pre">register</span></code> and <code class="docutils literal notranslate"><span class="pre">run</span></code>, which are responsible
to register transitions and execute local computations, respectively.</p>
<p>Developers should implement this method to register all possible transitions. To do so, developers should call
<code class="docutils literal notranslate"><span class="pre">self.register_transition(target,</span> <span class="pre">role,</span> <span class="pre">name)</span></code>, where they should provide the name of target transition and other parameters.
Beware that this is just a declaration of transitions and later in <cite>``app._transition`</cite> &lt;#transition-to-another-state-transitionself-name&gt;`_
eligibility of the transition will be checked. Accordingly, there is no need to check the app-instance role here.
This method will be called in <code class="docutils literal notranslate"><span class="pre">app.register</span></code> method to verify all transitions.</p>
<p>All the operations that should be executed as either local calculations or global aggregations should be implemented in the <code class="docutils literal notranslate"><span class="pre">run</span></code> method.
Depending on the roles, in case both roles are allowed, there can be a different set of operations to handle.
Meanwhile, developers should call the communication methods, in case it is needed, to communicate.
It will be called in <cite>``app.run()`</cite> &lt;#executing-states-computation-run&gt;`_ method so that the state perform its operations.</p>
</section>
<section id="id8">
<h2>Communication methods<a class="headerlink" href="#id8" title="Link to this heading">¶</a></h2>
<p>Generally, each state can communicate with other clients through different communication methods.</p>
<p>This method automatically handles SMPC usage and serialization and always returns the aggregated data. Aggregated data
contains the same data structure and shape as the one was sent out by each of the clients because it was summed up element-wise. Therefore,
to have structural data consistency, it considers SMPC usage as follows:</p>
<ul class="simple">
<li><p>Using SMPC: waits to receive the aggregated data from SMPC modules, it looks like waiting for just one client.</p></li>
<li><p>Without SMPC: waits to receive all client’s data, then internally aggregates them.</p></li>
</ul>
<p>Accordingly, FeatureCloud app developers no longer are required to consider SMPC usage because they always get the same
aggregated results in the coordinator. Provided aggregated results are not the average ones; therefore, they need to be averaged, if it’s apt to, separately.
If different data parts being sent by clients, using <code class="docutils literal notranslate"><span class="pre">aggregate_data</span></code> maybe troublesome because those data parts may vary in dimension and
data type. Hence, in such scenarios, developers can use <code class="docutils literal notranslate"><span class="pre">gather_data</span></code> to have access to the same data part of different clients
and pass them to <code class="docutils literal notranslate"><span class="pre">_aggregate</span></code> method separately to get the aggregated values.</p>
<p>FC app developers are allowed to call this method only for clients with the coordinator role.
This method calls the <code class="docutils literal notranslate"><span class="pre">await_data</span></code> method to wait for receiving data of all clients.
The gathered data will be in a list which includes the data of each client. In case there be more than data part shared by
each client, one solution to access related data is looping over the clients data and access the relative data part on different clients.
For instance, for two clients A and B:
A sends out:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data_to_send</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;test_A&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>while client B sends:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data_to_send</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="s2">&quot;test_B&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>the coordinator can aggregate the data as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">clients_lists</span><span class="p">,</span> <span class="n">clients_str</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">clients_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gather_data</span><span class="p">():</span>
    <span class="n">clients_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clients_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">clients_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clients_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>For receiving data from <code class="docutils literal notranslate"><span class="pre">n</span></code> clients, it can be called. It polls for data arrival every <code class="docutils literal notranslate"><span class="pre">DATA_POLL_INTERVAL</span></code> seconds,
and once it is received, deserializes the received data.</p>
<p>Once it is called, it communicates data to another specific client that was named by its <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<blockquote>
<div><p>Developers can configure the Secure Multi-Party Computation(SMPC) module by sending range, shards,
operation, and serialization parameters. In case of not calling the method, default configurations will be used
(More information on <a class="reference external" href="#secure-multi-party-computation-smpc">here</a>).</p>
</div></blockquote>
<p>Developers can use <code class="docutils literal notranslate"><span class="pre">send_data_to_coordinator</span></code> this method to Communicate data with the coordinator.
It provides the data for the FC Controller to be delivered to the coordinator. And if the coordinator calls it,
data will be directly appended to its list of incoming data. Developers should decide whether they want
to employ SMPC for securing the aggregation or not by setting <code class="docutils literal notranslate"><span class="pre">use_smpc</span></code> flag.</p>
<p>This should only be called for the coordinator to broadcasts data to all clients.</p>
</section>
<section id="shared-memory-methods">
<h2>Shared memory methods<a class="headerlink" href="#shared-memory-methods" title="Link to this heading">¶</a></h2>
<p>Even though all states will be run in the same container and inherited from the same class, they need to have shared memory
so developers can quickly transfer some local data from one state to another. These data can be either fixed, e.g.,
information about clients’ id, or dynamic, results of computations applied on the local data. Either way, the data is
located inside the unique <code class="docutils literal notranslate"><span class="pre">app</span></code> instance, which is a private member, and there are predefined methods and properties in
<code class="docutils literal notranslate"><span class="pre">AppState</span></code> to handle it.</p>
<p>Once developers want to transfer data from one state to another, they can call the <code class="docutils literal notranslate"><span class="pre">store</span></code> method and provide <code class="docutils literal notranslate"><span class="pre">key</span></code> argument,
to assign a name to the data part, and <code class="docutils literal notranslate"><span class="pre">value</span></code> argument for the data. <code class="docutils literal notranslate"><span class="pre">store</span></code> updates the shared memory by adding <code class="docutils literal notranslate"><span class="pre">key</span></code> to hold
‘value’. Beware that if <code class="docutils literal notranslate"><span class="pre">key</span></code> exists, it will be overridden by <code class="docutils literal notranslate"><span class="pre">store</span></code>. There is no restriction on <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>Once developers want to access specific shared data on the shared memory, all they need is the corresponding <code class="docutils literal notranslate"><span class="pre">key</span></code> and
calling <code class="docutils literal notranslate"><span class="pre">load</span></code> method to search the shared memory for it and return the value if it exists. If no <code class="docutils literal notranslate"><span class="pre">key</span></code> is found,
app execution will be interrupted.</p>
<p>In many scenarios, developers may condition their decisions on the role of the target app instance. For example, some transitions
may be exclusive to the coordinator and should be taken only on the app instance with the coordinator role. Accordingly, the coordinator
property in <code class="docutils literal notranslate"><span class="pre">AppSatate</span></code> will check the role and return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the app instance role is coordinator; otherwise, it will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Each app has a unique ID which will be shared with other participants in a federated workflow. In case a state needs
to communicate data to a specific client, it can use <code class="docutils literal notranslate"><span class="pre">clients</span></code> property to get a list of clients’ IDs. Developers can get the ID of the target app instance using the <code class="docutils literal notranslate"><span class="pre">id</span></code> property of <code class="docutils literal notranslate"><span class="pre">AppState</span></code>. Having these two properties can be helpful to distinguish between the ID of the target app instance from others.</p>
</section>
<section id="other-methods">
<h2>Other methods<a class="headerlink" href="#other-methods" title="Link to this heading">¶</a></h2>
<p>Developers should call this method to register a transition for the state by determining the name of
<code class="docutils literal notranslate"><span class="pre">target</span></code> state, <code class="docutils literal notranslate"><span class="pre">role</span></code> tuple of transitions, and a postfix name for generating the name of the transition.
In case of not providing the postfix, the name of the target state will be used. For naming the transitions,
we conventionally use <a href="#id11"><span class="problematic" id="id12">`name of source state`_</span></a><code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">of</span> <span class="pre">target</span> <span class="pre">state</span></code>. In <code class="docutils literal notranslate"><span class="pre">AppState.register</span></code>, <code class="docutils literal notranslate"><span class="pre">register_transition</span></code> of the states
will be called to verify and add all possible transitions.</p>
<p>Updates the status of the instance app for the front-end application. It can be called by any of the clients to report the client’s state.</p>
<ul class="simple">
<li><p>message: messaging any specifics about state or app.</p></li>
<li><p>progress: quantifies the approximate progress of the application.</p></li>
<li><p>state: message that describes actual/general state of the app.</p></li>
</ul>
<section id="registering-states-to-the-app-app-state">
<h3>Registering states to the app: <code class="docutils literal notranslate"><span class="pre">app_state</span></code><a class="headerlink" href="#registering-states-to-the-app-app-state" title="Link to this heading">¶</a></h3>
<p>Once FC app developers want to integrate their newly defined states, they can use <code class="docutils literal notranslate"><span class="pre">app_state</span></code>. FeatureCloud app
will always be instantiated in the <code class="docutils literal notranslate"><span class="pre">FeatureCloud.engine</span></code> package to be used by different modules. Each state should be
defined for at least one participant or coordinator role. In case states require any specific arguments, they should be sent by the <code class="docutils literal notranslate"><span class="pre">app_state</span></code> function.
For instance, to register the <code class="docutils literal notranslate"><span class="pre">initial</span></code> state with the constant role of <code class="docutils literal notranslate"><span class="pre">BOTH</span></code> and <code class="docutils literal notranslate"><span class="pre">app_name</span></code> as a state-specific argument,
we can use <code class="docutils literal notranslate"><span class="pre">app_state</span></code> as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@app_state</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;initial&#39;</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="n">BOTH</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ExampleState</span><span class="p">(</span><span class="n">State</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>This will automatically register <code class="docutils literal notranslate"><span class="pre">ExampleState</span></code> as the first state by the name of <code class="docutils literal notranslate"><span class="pre">initial</span></code> in the app. Meanwhile, once the state is instantiated, <code class="docutils literal notranslate"><span class="pre">app_name</span></code> will be passed to it.</p>
</section>
<section id="id10">
<h3>Verification mechanism<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h3>
<p>To verify the logic of defined states and transitions between them, FeatureCloud use a verification mechanism that operates
in two levels. In step level:
in app level, ever</p>
</section>
<section id="app-instance">
<h3>app instance<a class="headerlink" href="#app-instance" title="Link to this heading">¶</a></h3>
<p>Different parts of the FeatureCloud library should use the same instance of the <code class="docutils literal notranslate"><span class="pre">App</span></code> class. These parts are as follows:</p>
<ul class="simple">
<li><p>States: each state may need to be aware of the <a class="reference external" href="#roles">Role</a> for carrying on different operations and have access to the app’s
<cite>``internal`</cite> &lt;#shared-memory-for-states-app_internal&gt;`_ for data from other states. Therefore, the same app instance should be used for registering the states.</p></li>
<li><p>api: In the <code class="docutils literal notranslate"><span class="pre">api</span></code> package, through the <code class="docutils literal notranslate"><span class="pre">bottle</span></code> library, the controller informs the app instance about its role, its ID, and ID of other
clients. The same app instance should be used for that purpose too.</p></li>
</ul>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p><span class="raw-html-m2r"><a id="1">[1]</a></span>
Matschinske, J., Späth, J., Nasirigerdeh, R., Torkzadehmahani, R., Hartebrodt, A., Orbán, B., Fejér, S., Zolotareva, O., Bakhtiari, M., Bihari, B. and Bloice, M., 2021. The FeatureCloud AI Store for Federated Learning in Biomedicine and Beyond. arXiv preprint arXiv:2105.05734.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/fc_logo.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="quick_start.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="complete_description.html">FeatureCloud Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="code.html">API Connector Python</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, author names.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/complete_description_old.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>